if (length(all_outliers) > 0) {
houses <- houses[-all_outliers, ]
cat("Удалено строк:", length(all_outliers), "\n")
cat("Осталось наблюдений:", nrow(houses), "\n")
} else {
cat("Выбросы не обнаружены.\n")
}
# 1) Гистограммы для каждой из 4 переменных
par(mfrow = c(2,2), mar = c(4,4,2,1))
n <- nrow(houses)
k <- ceiling(1 + 3.322 * log10(n))
hist(houses$age, main = "Гистограмма: Возраст", xlab = "Возраст", breaks = k)
hist(houses$metro_distance, main = "Гистограмма: Дистанция до метро", xlab = "Дистанция до метро", breaks = k)
hist(houses$number_of_convinience_store_close, main = "Гистограмма: Количество магазинов рядом", xlab = "Количество магазинов рядом", breaks = k)
hist(houses$price_per_unit, main = "Гистограмма: Стоимость за ед площади", xlab = "Стоимость за ед площади", breaks = k)
par(mfrow = c(1,1))
# 2) Преобразование переменных в категориальные с объединением малых интервалов
# Функция для создания категорий с объединением интервалов с малым количеством наблюдений
create_categories_with_merge <- function(var, var_name, min_freq = 0.05, initial_groups = 12) {
# Убираем NA для расчетов
var_clean <- var[!is.na(var)]
n <- length(var_clean)
min_count <- max(1, round(n * min_freq))  # Минимальное количество наблюдений в группе
# Создаем начальные интервалы по квантилям (равномерное распределение наблюдений)
probs <- seq(0, 1, length.out = initial_groups + 1)
breaks <- quantile(var_clean, probs = probs, na.rm = TRUE)
breaks <- unique(breaks)  # Убираем дубликаты
# Создаем категории
categories <- cut(var, breaks = breaks, include.lowest = TRUE, labels = FALSE)
# Итеративное объединение малых интервалов
max_iterations <- 50
iteration <- 0
while (iteration < max_iterations) {
freq_table <- table(categories, useNA = "no")
small_groups <- which(freq_table < min_count)
if (length(small_groups) == 0) {
break  # Все группы достаточно большие
}
# Объединяем малые группы с соседними
for (sg in small_groups) {
# Находим соседние группы
all_groups <- as.numeric(names(freq_table))
current_pos <- which(all_groups == sg)
if (current_pos > 1 && current_pos < length(all_groups)) {
# Есть соседи с обеих сторон
left_neighbor <- all_groups[current_pos - 1]
right_neighbor <- all_groups[current_pos + 1]
# Выбираем соседа с большим количеством наблюдений
if (freq_table[as.character(left_neighbor)] >= freq_table[as.character(right_neighbor)]) {
categories[categories == sg] <- left_neighbor
} else {
categories[categories == sg] <- right_neighbor
}
} else if (current_pos > 1) {
# Только левый сосед
left_neighbor <- all_groups[current_pos - 1]
categories[categories == sg] <- left_neighbor
} else if (current_pos < length(all_groups)) {
# Только правый сосед
right_neighbor <- all_groups[current_pos + 1]
categories[categories == sg] <- right_neighbor
}
}
iteration <- iteration + 1
}
# Создаем фактор с понятными названиями
unique_cats <- sort(unique(categories[!is.na(categories)]))
n_cats <- length(unique_cats)
# Создаем метки для категорий на основе реальных значений
labels <- character(n_cats)
for (i in seq_along(unique_cats)) {
cat_val <- unique_cats[i]
cat_indices <- which(categories == cat_val)
if (length(cat_indices) > 0) {
min_val <- min(var[cat_indices], na.rm = TRUE)
max_val <- max(var[cat_indices], na.rm = TRUE)
labels[i] <- paste0(var_name, "_", sprintf("%.2f", min_val), "_", sprintf("%.2f", max_val))
}
}
# Создаем фактор
result <- factor(categories, levels = unique_cats, labels = labels)
# Выводим информацию
cat("\nКатегоризация для", var_name, ":\n")
cat("Исходное количество интервалов:", initial_groups, "\n")
cat("Финальное количество групп:", n_cats, "\n")
cat("Минимальное количество наблюдений в группе:", min_count, "\n")
cat("Распределение по группам:\n")
print(table(result, useNA = "ifany"))
return(result)
}
# Категоризация для всех переменных с объединением малых интервалов
houses$fMetro <- create_categories_with_merge(houses$metro_distance, "Metro", min_freq = 0.05, initial_groups = 6)
houses$fPrice <- create_categories_with_merge(houses$price_per_unit, "Price", min_freq = 0.05, initial_groups = 6)
houses$fAge <- create_categories_with_merge(houses$age, "Age", min_freq = 0.05, initial_groups = 6)
houses$fStores <- create_categories_with_merge(houses$number_of_convinience_store_close, "Stores", min_freq = 0.05, initial_groups = 6)
# Гистограммы категориальных переменных после категоризации
cat("\n=== Гистограммы категориальных переменных ===\n")
par(mfrow = c(2, 2), mar = c(4, 4, 2, 1))
barplot(table(houses$fAge, useNA = "ifany"),
main = "Распределение: Возраст (категории)",
xlab = "Категории возраста",
ylab = "Частота",
las = 2, cex.names = 0.7)
barplot(table(houses$fMetro, useNA = "ifany"),
main = "Распределение: Дистанция до метро (категории)",
xlab = "Категории дистанции",
ylab = "Частота",
las = 2, cex.names = 0.7)
barplot(table(houses$fPrice, useNA = "ifany"),
main = "Распределение: Стоимость за ед площади (категории)",
xlab = "Категории стоимости",
ylab = "Частота",
las = 2, cex.names = 0.7)
barplot(table(houses$fStores, useNA = "ifany"),
main = "Распределение: Количество магазинов рядом (категории)",
xlab = "Категории количества магазинов",
ylab = "Частота",
las = 2, cex.names = 0.7)
par(mfrow = c(1, 1))
# Убираем NA
df_nomiss <- houses[!is.na(houses$fAge) & !is.na(houses$fMetro) & !is.na(houses$fPrice) & !is.na(houses$fStores), ]
# Список всех категориальных переменных
cat_vars <- list(
fAge = df_nomiss$fAge,
fMetro = df_nomiss$fMetro,
fPrice = df_nomiss$fPrice,
fStores = df_nomiss$fStores
)
# Названия переменных
var_names <- c("Возраст", "Дистанция до метро", "Стоимость за ед площади", "Количество магазинов рядом")
names(var_names) <- names(cat_vars)
# Создаем все возможные пары
n_vars <- length(cat_vars)
for (i in 1:(n_vars - 1)) {
for (j in (i + 1):n_vars) {
var1_name <- names(cat_vars)[i]
var2_name <- names(cat_vars)[j]
cat("\n", "=", rep("=", 70), "\n", sep = "")
cat("Таблица сопряженности:", var_names[var1_name], "x", var_names[var2_name], "\n")
cat("", rep("=", 70), "\n", sep = "")
# Создаем таблицу сопряженности
contingency <- table(cat_vars[[i]], cat_vars[[j]])
print(contingency)
# χ²-тест с поправкой Йейтса (только для таблиц 2x2)
# Для больших таблиц поправка Йейтса не применяется
if (nrow(contingency) == 2 && ncol(contingency) == 2) {
chi_res <- chisq.test(contingency, correct = TRUE)
cat("\nχ²-тест с поправкой Йейтса:\n")
} else {
chi_res <- chisq.test(contingency, correct = FALSE)
cat("\nχ²-тест:\n")
}
print(chi_res)
cat("\nОжидаемые частоты:\n")
print(round(chi_res$expected, 2))
}
}
# Выведем pairs.panels для всех 4 числовых переменных (убираем NA)
num_data <- na.omit(houses[, c("age", "metro_distance", "number_of_convinience_store_close", "price_per_unit")])
pairs.panels(num_data,
method = "spearman", # показываем Спирмена на диаграммах
hist.col = "lightgray",
density = TRUE,
lm = FALSE)
cat("\n=== Корреляционный анализ для выбранных пар переменных ===\n")
# 1) Корреляционный анализ: metro_distance vs number_of_convinience_store_close
cat("\n1. Дистанция до метро vs Количество магазинов рядом\n")
cat("H0: rho = 0 (нет корреляции между дистанцией до метро и количеством магазинов рядом)\n")
cat("H1: rho != 0 (есть корреляция между дистанцией до метро и количеством магазинов рядом)\n")
df_md_stores <- na.omit(houses[, c("metro_distance", "number_of_convinience_store_close")])
spearman_md_stores <- cor.test(df_md_stores$metro_distance, df_md_stores$number_of_convinience_store_close,
method = "spearman", exact = FALSE)
print(spearman_md_stores)
# График
plot(df_md_stores$metro_distance, df_md_stores$number_of_convinience_store_close,
pch = 19, col = "blue",
xlab = "Дистанция до метро", ylab = "Количество магазинов рядом",
main = paste0("Дистанция до метро vs Количество магазинов рядом\nSpearman rho = ",
round(spearman_md_stores$estimate, 3),
", p = ", signif(spearman_md_stores$p.value, 3)))
lines(lowess(df_md_stores$metro_distance, df_md_stores$number_of_convinience_store_close),
col = "red", lwd = 2)
# Интерпретация
if (spearman_md_stores$p.value < 0.05) {
cat("Вывод: H0 отвергается (p < 0.05). Существует статистически значимая корреляция.\n")
} else {
cat("Вывод: H0 не отвергается (p >= 0.05). Нет статистически значимой корреляции.\n")
}
# 2) Корреляционный анализ: metro_distance vs price_per_unit
cat("\n2. Дистанция до метро vs Стоимость за ед. площади\n")
cat("H0: rho = 0 (нет корреляции между дистанцией до метро и стоимостью за ед. площади)\n")
cat("H1: rho != 0 (есть корреляция между дистанцией до метро и стоимостью за ед. площади)\n")
df_md_price <- na.omit(houses[, c("metro_distance", "price_per_unit")])
spearman_md_price <- cor.test(df_md_price$metro_distance, df_md_price$price_per_unit,
method = "spearman", exact = FALSE)
print(spearman_md_price)
# График
plot(df_md_price$metro_distance, df_md_price$price_per_unit,
pch = 19, col = "blue",
xlab = "Дистанция до метро", ylab = "Стоимость за ед. площади",
main = paste0("Дистанция до метро vs Стоимость за ед. площади\nSpearman rho = ",
round(spearman_md_price$estimate, 3),
", p = ", signif(spearman_md_price$p.value, 3)))
lines(lowess(df_md_price$metro_distance, df_md_price$price_per_unit),
col = "red", lwd = 2)
# Интерпретация
if (spearman_md_price$p.value < 0.05) {
cat("Вывод: H0 отвергается (p < 0.05). Существует статистически значимая корреляция.\n")
} else {
cat("Вывод: H0 не отвергается (p >= 0.05). Нет статистически значимой корреляции.\n")
}
# 3) Корреляционный анализ: number_of_convinience_store_close vs price_per_unit
cat("\n3. Количество магазинов рядом vs Стоимость за ед. площади\n")
cat("H0: rho = 0 (нет корреляции между количеством магазинов рядом и стоимостью за ед. площади)\n")
cat("H1: rho != 0 (есть корреляция между количеством магазинов рядом и стоимостью за ед. площади)\n")
df_stores_price <- na.omit(houses[, c("number_of_convinience_store_close", "price_per_unit")])
spearman_stores_price <- cor.test(df_stores_price$number_of_convinience_store_close, df_stores_price$price_per_unit,
method = "spearman", exact = FALSE)
print(spearman_stores_price)
# График
plot(df_stores_price$number_of_convinience_store_close, df_stores_price$price_per_unit,
pch = 19, col = "blue",
xlab = "Количество магазинов рядом", ylab = "Стоимость за ед. площади",
main = paste0("Количество магазинов рядом vs Стоимость за ед. площади\nSpearman rho = ",
round(spearman_stores_price$estimate, 3),
", p = ", signif(spearman_stores_price$p.value, 3)))
lines(lowess(df_stores_price$number_of_convinience_store_close, df_stores_price$price_per_unit),
col = "red", lwd = 2)
# Интерпретация
if (spearman_stores_price$p.value < 0.05) {
cat("Вывод: H0 отвергается (p < 0.05). Существует статистически значимая корреляция.\n")
} else {
cat("Вывод: H0 не отвергается (p >= 0.05). Нет статистически значимой корреляции.\n")
}
# === 0. Очистка окружения ===
rm(list = ls())
if (exists(".Random.seed")) rm(.Random.seed)
# === 1. Загрузка данных ===
# Устанавливаем пакет readxl если нужно
if(!require(readxl)) install.packages("readxl", repos = "https://cran.r-project.org")
library(readxl)
# Загружаем данные из Excel файла с правильными типами колонок
# Порядок: Номер (skip), Дата сделка (skip), Возраст, Дистанция до метро, Количество магазинов рядом, Широта, Долгота, Стоимость за ед площади
file_path <- "houses/data.xlsx"
data <- read_excel(file_path, col_types = c("numeric", "skip", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric"))
# Переименовываем колонки для удобства
colnames(data) <- c("Номер", "Возраст", "Дистанция_до_метро", "Количество_магазинов_рядом", "Широта", "Долгота", "Стоимость_за_ед_площади")
# === 2. Подготовка данных ===
df <- data.frame(
metro_distance = as.numeric(data$Дистанция_до_метро),      # Независимая переменная: Расстояние до метро
price_per_unit = as.numeric(data$Стоимость_за_ед_площади)  # Зависимая переменная: Стоимость за м2
)
# Убедимся, что переменные numeric
df$metro_distance <- as.numeric(df$metro_distance)
df$price_per_unit <- as.numeric(df$price_per_unit)
cat("Исходное количество наблюдений:", nrow(df), "\n")
# === 2.1. Удаление выбросов методом IQR ===
cat("\n=== Обнаружение и удаление выбросов ===\n")
# Функция для обнаружения выбросов по методу IQR
detect_outliers_iqr <- function(var, var_name) {
var_clean <- var[!is.na(var)]
Q1 <- quantile(var_clean, 0.25, na.rm = TRUE)
Q3 <- quantile(var_clean, 0.75, na.rm = TRUE)
IQR_val <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR_val
upper_bound <- Q3 + 1.5 * IQR_val
outliers <- which(var < lower_bound | var > upper_bound)
cat("\n", var_name, ":\n")
cat("  Q1 =", round(Q1, 2), ", Q3 =", round(Q3, 2), ", IQR =", round(IQR_val, 2), "\n")
cat("  Границы: [", round(lower_bound, 2), ", ", round(upper_bound, 2), "]\n", sep = "")
cat("  Количество выбросов:", length(outliers), "\n")
return(outliers)
}
# Обнаруживаем выбросы для каждой переменной
outliers_metro <- detect_outliers_iqr(df$metro_distance, "Расстояние до метро")
outliers_price <- detect_outliers_iqr(df$price_per_unit, "Стоимость за м2")
# Объединяем все индексы выбросов
all_outliers <- unique(c(outliers_metro, outliers_price))
cat("\nОбщее количество строк с выбросами (по любой переменной):", length(all_outliers), "\n")
cat("Процент выбросов:", round(100 * length(all_outliers) / nrow(df), 2), "%\n")
# Удаляем выбросы
if (length(all_outliers) > 0) {
df <- df[-all_outliers, ]
cat("Удалено строк:", length(all_outliers), "\n")
cat("Осталось наблюдений:", nrow(df), "\n")
} else {
cat("Выбросы не обнаружены.\n")
}
# === 2.2. Убираем NA ===
df <- na.omit(df)
cat("\nКоличество наблюдений после удаления NA:", nrow(df), "\n")
cat("Переменные:\n")
cat("  metro_distance - Расстояние до метро (независимая)\n")
cat("  price_per_unit - Стоимость за м2 (зависимая)\n")
# === 3. Линейная регрессия price_per_unit ~ metro_distance ===
lm_model <- lm(price_per_unit ~ metro_distance, data = df)
# Вывод результатов модели
summary(lm_model)
# === 4. Остатки ===
residuals_lm <- residuals(lm_model)
std_resid <- rstandard(lm_model)
hist(std_resid, breaks = 20, col = "lightgray", border = "black",
main = "Гистограмма стандартизированных остатков", xlab = "Стандартизированные остатки")
# === 5. График модели ===
plot(df$metro_distance, df$price_per_unit,
pch = 19, col = "blue",
xlab = "Расстояние до метро", ylab = "Стоимость за м2",
main = "Линейная регрессия: Стоимость за м2 ~ Расстояние до метро")
abline(lm_model, col = "red", lwd = 2)
# === 6. График остатков ===
plot(df$metro_distance, residuals_lm,
pch = 19, col = "darkgreen",
xlab = "Расстояние до метро", ylab = "Остатки",
main = "График остатков")
abline(h = 0, col = "red", lwd = 2)
# === 7. Q-Q график остатков ===
qqnorm(residuals_lm, main = "Q-Q Plot остатков")
qqline(residuals_lm, col = "red", lwd = 2)
# === 8. Гистограмма остатков ===
hist(residuals_lm,
breaks = 9, col = "lightgray", border = "black",
main = "Гистограмма остатков", xlab = "Остатки")
# === 9. Уравнение регрессии ===
coeffs <- coef(lm_model)
eq <- paste0("Стоимость_за_м2 = ",
round(coeffs[1], 2), " + ",
round(coeffs[2], 2), " * Расстояние_до_метро")
cat("\nУравнение регрессии:\n", eq, "\n")
# === 0. Очистка окружения ===
rm(list = ls())
if (exists(".Random.seed")) rm(.Random.seed)
# === 1. Загрузка данных ===
# Устанавливаем пакет readxl если нужно
if(!require(readxl)) install.packages("readxl", repos = "https://cran.r-project.org")
library(readxl)
# Загружаем данные из Excel файла с правильными типами колонок
# Порядок: Номер (skip), Дата сделка (skip), Возраст, Дистанция до метро, Количество магазинов рядом, Широта, Долгота, Стоимость за ед площади
file_path <- "houses/data.xlsx"
data <- read_excel(file_path, col_types = c("numeric", "skip", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric"))
# Переименовываем колонки для удобства
colnames(data) <- c("Номер", "Возраст", "Дистанция_до_метро", "Количество_магазинов_рядом", "Широта", "Долгота", "Стоимость_за_ед_площади")
# === 2. Подготовка данных ===
df <- data.frame(
metro_distance = as.numeric(data$Дистанция_до_метро),      # Независимая переменная: Расстояние до метро
price_per_unit = as.numeric(data$Стоимость_за_ед_площади)   # Зависимая переменная: Стоимость за м2
)
# Убедимся, что переменные numeric
df$metro_distance <- as.numeric(df$metro_distance)
df$price_per_unit <- as.numeric(df$price_per_unit)
cat("Исходное количество наблюдений:", nrow(df), "\n")
# === 2.1. Удаление выбросов методом IQR ===
cat("\n=== Обнаружение и удаление выбросов ===\n")
# Функция для обнаружения выбросов по методу IQR
detect_outliers_iqr <- function(var, var_name) {
var_clean <- var[!is.na(var)]
Q1 <- quantile(var_clean, 0.25, na.rm = TRUE)
Q3 <- quantile(var_clean, 0.75, na.rm = TRUE)
IQR_val <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR_val
upper_bound <- Q3 + 1.5 * IQR_val
outliers <- which(var < lower_bound | var > upper_bound)
cat("\n", var_name, ":\n")
cat("  Q1 =", round(Q1, 2), ", Q3 =", round(Q3, 2), ", IQR =", round(IQR_val, 2), "\n")
cat("  Границы: [", round(lower_bound, 2), ", ", round(upper_bound, 2), "]\n", sep = "")
cat("  Количество выбросов:", length(outliers), "\n")
return(outliers)
}
# Обнаруживаем выбросы для каждой переменной
outliers_metro <- detect_outliers_iqr(df$metro_distance, "Расстояние до метро")
outliers_price <- detect_outliers_iqr(df$price_per_unit, "Стоимость за м2")
# Объединяем все индексы выбросов
all_outliers <- unique(c(outliers_metro, outliers_price))
cat("\nОбщее количество строк с выбросами (по любой переменной):", length(all_outliers), "\n")
cat("Процент выбросов:", round(100 * length(all_outliers) / nrow(df), 2), "%\n")
# Удаляем выбросы
if (length(all_outliers) > 0) {
df <- df[-all_outliers, ]
cat("Удалено строк:", length(all_outliers), "\n")
cat("Осталось наблюдений:", nrow(df), "\n")
} else {
cat("Выбросы не обнаружены.\n")
}
# === 2.2. Убираем NA ===
df <- na.omit(df)
cat("\nКоличество наблюдений после удаления NA:", nrow(df), "\n")
cat("Переменные:\n")
cat("  metro_distance - Расстояние до метро\n")
cat("  price_per_unit - Стоимость за м2 (зависимая переменная)\n")
# === 3. Формирование фактора (metro_distance в 3 равные группы) ===
# Разбиваем на три равные группы по квантилям
df$metro_group <- cut(df$metro_distance,
breaks = quantile(df$metro_distance, probs = seq(0, 1, length = 4), na.rm = TRUE),
include.lowest = TRUE,
labels = c("Близко", "Средне", "Далеко"))
# Проверка распределения по группам
cat("\nРаспределение по группам расстояния до метро:\n")
print(table(df$metro_group))
# === 4. Однофакторный дисперсионный анализ (ANOVA) ===
# Зависимая переменная: price_per_unit (Стоимость за м2)
# Фактор: metro_group (группы расстояния до метро)
anova_model <- aov(price_per_unit ~ metro_group, data = df)
summary(anova_model)
# === 6. График для наглядности ===
boxplot(price_per_unit ~ metro_group, data = df,
col = c("lightblue", "lightgreen", "lightpink"),
main = "Стоимость за м2 по группам расстояния до метро",
xlab = "Группа расстояния до метро", ylab = "Стоимость за м2")
# === 7. Дополнительный анализ: создаем вторую категориальную переменную ===
# Создаем категориальную переменную на основе стоимости (высокая/низкая)
median_price <- median(df$price_per_unit, na.rm = TRUE)
df$price_group <- as.factor(ifelse(df$price_per_unit > median_price, "Высокая_стоимость", "Низкая_стоимость"))
cat("\nРаспределение по группам стоимости:\n")
print(table(df$price_group))
# === 8. Двухфакторный дисперсионный анализ (metro_group и price_group) ===
# Проверяем влияние группы расстояния до метро на стоимость
# price_group может использоваться как дополнительный фактор для проверки взаимодействия
anova_model2 <- aov(price_per_unit ~ metro_group * price_group, data = df)
summary(anova_model2)
# === 0. Очистка окружения ===
rm(list = ls())
if (exists(".Random.seed")) rm(.Random.seed)
# === 1. Загрузка данных ===
# Устанавливаем пакет readxl если нужно
if(!require(readxl)) install.packages("readxl", repos = "https://cran.r-project.org")
library(readxl)
# Загружаем данные из Excel файла с правильными типами колонок
# Порядок: Номер (skip), Дата сделка (skip), Возраст, Дистанция до метро, Количество магазинов рядом, Широта, Долгота, Стоимость за ед площади
file_path <- "houses/data.xlsx"
data <- read_excel(file_path, col_types = c("numeric", "skip", "numeric", "numeric", "numeric", "numeric", "numeric", "numeric"))
# Переименовываем колонки для удобства
colnames(data) <- c("Номер", "Возраст", "Дистанция_до_метро", "Количество_магазинов_рядом", "Широта", "Долгота", "Стоимость_за_ед_площади")
# === 2. Подготовка данных ===
df <- data.frame(
metro_distance = as.numeric(data$Дистанция_до_метро),      # Независимая переменная: Расстояние до метро
price_per_unit = as.numeric(data$Стоимость_за_ед_площади), # Зависимая переменная: Стоимость за м2
number_of_stores = as.numeric(data$Количество_магазинов_рядом)  # Количество магазинов рядом
)
# Убедимся, что переменные numeric
df$metro_distance <- as.numeric(df$metro_distance)
df$price_per_unit <- as.numeric(df$price_per_unit)
cat("Исходное количество наблюдений:", nrow(df), "\n")
# === 2.1. Удаление выбросов методом IQR ===
cat("\n=== Обнаружение и удаление выбросов ===\n")
# Функция для обнаружения выбросов по методу IQR
detect_outliers_iqr <- function(var, var_name) {
var_clean <- var[!is.na(var)]
Q1 <- quantile(var_clean, 0.25, na.rm = TRUE)
Q3 <- quantile(var_clean, 0.75, na.rm = TRUE)
IQR_val <- Q3 - Q1
lower_bound <- Q1 - 1.5 * IQR_val
upper_bound <- Q3 + 1.5 * IQR_val
outliers <- which(var < lower_bound | var > upper_bound)
cat("\n", var_name, ":\n")
cat("  Q1 =", round(Q1, 2), ", Q3 =", round(Q3, 2), ", IQR =", round(IQR_val, 2), "\n")
cat("  Границы: [", round(lower_bound, 2), ", ", round(upper_bound, 2), "]\n", sep = "")
cat("  Количество выбросов:", length(outliers), "\n")
return(outliers)
}
# Обнаруживаем выбросы для каждой переменной
outliers_metro <- detect_outliers_iqr(df$metro_distance, "Расстояние до метро")
outliers_price <- detect_outliers_iqr(df$price_per_unit, "Стоимость за м2")
outliers_stores <- detect_outliers_iqr(df$number_of_stores, "Количество магазинов рядом")
# Объединяем все индексы выбросов
all_outliers <- unique(c(outliers_metro, outliers_price, outliers_stores))
cat("\nОбщее количество строк с выбросами (по любой переменной):", length(all_outliers), "\n")
cat("Процент выбросов:", round(100 * length(all_outliers) / nrow(df), 2), "%\n")
# Удаляем выбросы
if (length(all_outliers) > 0) {
df <- df[-all_outliers, ]
cat("Удалено строк:", length(all_outliers), "\n")
cat("Осталось наблюдений:", nrow(df), "\n")
} else {
cat("Выбросы не обнаружены.\n")
}
# === 2.2. Убираем NA ===
df <- na.omit(df)
cat("\nКоличество наблюдений после удаления NA:", nrow(df), "\n")
cat("Переменные:\n")
cat("  metro_distance - Расстояние до метро\n")
cat("  price_per_unit - Стоимость за м2 (зависимая переменная)\n")
cat("  number_of_stores - Количество магазинов рядом\n")
# === 3. Формирование фактора (metro_distance в 3 равные группы) ===
# Разбиваем на три равные группы по квантилям
df$metro_group <- cut(df$metro_distance,
breaks = quantile(df$metro_distance, probs = seq(0, 1, length = 4), na.rm = TRUE),
include.lowest = TRUE,
labels = c("Близко", "Средне", "Далеко"))
# Проверка распределения по группам
cat("\nРаспределение по группам расстояния до метро:\n")
print(table(df$metro_group))
# === 4. Однофакторный дисперсионный анализ (ANOVA) ===
# Зависимая переменная: price_per_unit (Стоимость за м2)
# Фактор: metro_group (группы расстояния до метро)
anova_model <- aov(price_per_unit ~ metro_group, data = df)
summary(anova_model)
# === 6. График для наглядности ===
boxplot(price_per_unit ~ metro_group, data = df,
col = c("lightblue", "lightgreen", "lightpink"),
main = "Стоимость за м2 по группам расстояния до метро",
xlab = "Группа расстояния до метро", ylab = "Стоимость за м2")
# === 7. Формирование второго фактора (количество магазинов рядом в группы) ===
# Разбиваем на три равные группы по квантилям
df$stores_group <- cut(df$number_of_stores,
breaks = quantile(df$number_of_stores, probs = seq(0, 1, length = 4), na.rm = TRUE),
include.lowest = TRUE,
labels = c("Мало", "Средне", "Много"))
cat("\nРаспределение по группам количества магазинов рядом:\n")
print(table(df$stores_group))
# === 8. Двухфакторный дисперсионный анализ (metro_group и stores_group) ===
# Проверяем влияние группы расстояния до метро и количества магазинов рядом на стоимость
anova_model2 <- aov(price_per_unit ~ metro_group * stores_group, data = df)
summary(anova_model2)
